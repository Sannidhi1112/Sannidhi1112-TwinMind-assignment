package com.twinmind.voicerecorder.data.remote

import android.content.Context
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject

/**
 * Mock summary service that simulates streaming API calls
 * In production, this would call an LLM API like GPT-4 or Gemini
 */
class SummaryService @Inject constructor(
    private val context: Context
) {
    data class SummaryResponse(
        val title: String,
        val summary: String,
        val actionItems: List<String>,
        val keyPoints: List<String>
    )

    suspend fun generateSummary(transcript: String): Flow<String> = flow {
        // Simulate streaming response
        val summaryParts = listOf(
            "# Meeting Summary\n\n",
            "## Title\n",
            "Voice Recording Summary\n\n",
            "## Summary\n",
            "This is a mock summary generated from the transcript. ",
            "In a production environment, this would be generated by an LLM ",
            "analyzing the full transcript and extracting key information.\n\n",
            "## Action Items\n",
            "- Review the recording\n",
            "- Follow up on discussed topics\n",
            "- Share summary with team\n\n",
            "## Key Points\n",
            "- Recording completed successfully\n",
            "- Transcription processed\n",
            "- Summary generated\n"
        )

        for (part in summaryParts) {
            delay(200) // Simulate streaming delay
            emit(part)
        }
    }

    suspend fun parseSummaryResponse(fullText: String): SummaryResponse {
        // Simple parsing of markdown-formatted summary
        val lines = fullText.split("\n")

        var title = "Voice Recording"
        val summaryBuilder = StringBuilder()
        val actionItems = mutableListOf<String>()
        val keyPoints = mutableListOf<String>()

        var currentSection = ""

        for (line in lines) {
            when {
                line.startsWith("## Title") -> currentSection = "title"
                line.startsWith("## Summary") -> currentSection = "summary"
                line.startsWith("## Action Items") -> currentSection = "actions"
                line.startsWith("## Key Points") -> currentSection = "keypoints"
                line.startsWith("- ") -> {
                    when (currentSection) {
                        "actions" -> actionItems.add(line.substring(2))
                        "keypoints" -> keyPoints.add(line.substring(2))
                    }
                }
                line.isNotBlank() && !line.startsWith("#") -> {
                    when (currentSection) {
                        "title" -> title = line
                        "summary" -> summaryBuilder.append(line).append(" ")
                    }
                }
            }
        }

        return SummaryResponse(
            title = title,
            summary = summaryBuilder.toString().trim(),
            actionItems = actionItems,
            keyPoints = keyPoints
        )
    }
}
